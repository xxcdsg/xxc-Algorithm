## [Mondriaan's Dream](https://vjudge.net/problem/HDU-1400)

* 问题描述：你可以横着放$1*2$的方块，或者竖着放$2*1$的方块，问填满n\*m的区域的方案数
* 用$dp[i][j]$描述第$i$行填满后第$i+1$的状态
* 从第$i$位转移到第$i+1$位，先假设全是竖着放的，那么有转移方程$dp[i][j] = dp[i - 1][sum - 1 - j]$
* 枚举位数$k$，如果$j$的第$k$位与第$k+1$位都是1，那么说明这个也可以换成横着放的，因此有$dp[i][j]=dp[i][j \oplus f(k)]$
* 如果先枚举下一位状态，再枚举取消的位数，那么就有可能状态A从B转移到C与从D转移到状态C导致计数重复，因此要先枚举操作，即取消的位数，再枚举状态，才不会计数重复

```cpp
// xxc
#include<bits/stdc++.h>
using namespace std;

#define sum (1 << w)
#define f(x) (1 << (x))
#define ll long long

const int N = 12;

ll dp[N][1 << N];

void test(){
	int h,w;
	while(cin >> h >> w,h != 0){
		memset(dp,0,sizeof(dp));
		dp[0][0] = 1;//第0行填完,第一行什么都没有为初始状态
		for(int i = 1;i <= h;i++){//填这一行
			for(int s = sum;s >= 0;s--) dp[i][s] += dp[i - 1][sum - 1 - s];
			for(int j = 1;j <= w;j++){
				for(int s = sum;s >= 0;s--){
					if((s >> (j - 1)) & 1){//这一位有
						if((s >> j) & 1) dp[i][s ^ f(j - 1) ^ f(j)] += dp[i][s];
						//下一位也有,那么可以转移为取消的
						//因为是一位一位取消的，就不会出现取消先取消前面再取消后面与先取消后面再取消前面导致重复的情况
					}
				}
			}
		}
		cout << dp[h][0] << '\n';
	}
}

int main(){
	int t = 1;//cin >> t;
	while(t--){
		test();
	}
}
```

* 该题的特征就是对应每个状态来说，它要转移到的状态较多，很难在一次循环中得到，并且它中途会经过不同的状态再回到同一个状态，那么我们枚举不同的转移操作就可以限制操作的顺序从而去除重复的计数
* 1.难以确定每个状态的所有转移目标状态
* 2.一个状态可以通过不同路径到达同一状态（但不能重复计数）
* 3.对于相同的初始状态与目标状态，中间的转移过程可以交换，不影响目标状态
* 那么就可以限制转移过程的顺序来dp