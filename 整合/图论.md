# 图论

## 树的直径

* 用一次bfs找端点，再用一次bfs找直径

* [A - Roads in the North](https://vjudge.net/problem/POJ-2631)

```c++
#include<queue>
#include<iostream>
using namespace std;
const int MAXN = 1e4 + 10;
struct edge{
	int v,dis;
	edge* nex;
}ed[MAXN * 2];
edge* head[MAXN];
int ptop = 0,ans = 0;
bool use[MAXN];
struct pos{
	int x;
	int dis;
	bool operator <(const pos &x)const{
		return dis > x.dis;
	}//重载运算符
};
priority_queue<pos> qu;
int bfs(int u){
	pos tem;
	tem.x = u,tem.dis = 0;
	qu.push(tem);
	int x;
	while(!qu.empty()){
		x = qu.top().x;
		int pre = qu.top().dis;
		ans = pre;
		qu.pop();
		edge* p = head[x];
		while(p != NULL){
			int v = p -> v,dis = p -> dis;
			p = p -> nex;
			if(!use[v]){
				use[v] = 1;
				pos tem;
				tem.x = v,tem.dis = dis + pre;
				qu.push(tem);
			}
		}
	}
	return x;
}
void add(int u,int v,int dis){
	ed[ptop].v = v;
	ed[ptop].dis = dis;
	ed[ptop].nex = head[u];
	head[u] = &ed[ptop];
	ptop++;
}
int main()
{
	int u,v,dis;
	while(~scanf("%d %d %d",&u,&v,&dis)){
		add(u,v,dis);
		add(v,u,dis);
	}
	use[u] = 1;
	u = bfs(u);
	memset(use,0,sizeof(use));
	use[u] = 1;
	bfs(u);
	cout << ans << endl;
}
```

## 树的重心

* 重心的性质：去掉后，剩下的连接部分的最大数量最小
* 也就是子树最大值最小，求出所有节点的子树的最大值即可
* 用dfs可以找到所有节点的子节点子树，但是不知道父节点方向的子树，因为知道点的数量为n，所以只要用n减去所有子节点子树数量之和再减1就能得出父节点的子树数量

```c++
#include<iostream>
#include<algorithm>
using namespace std;
const int MAXN = 5e4 + 10;
struct edge{
	int v;
	edge* nex;
}ed[MAXN * 2];
edge* head[MAXN];
int ptop = 0;
void add(int u,int v){
	ed[ptop].v = v;
	ed[ptop].nex = head[u];
	head[u] = &ed[ptop];
	ptop++;
}
int sz[MAXN];
pair<int,int> ans[MAXN];
bool use[MAXN];
int n;
void find(int dad,int x){
	edge* p = head[x];
	sz[x] = 1;
	int ma = 0;
	while(p != NULL){
		int v = p -> v;
		p = p -> nex;
		if(v == dad)
			continue;
		if(!use[v])
			find(x,v);
		use[v] = 1;
		sz[x] += sz[v];
		ma = max(sz[v],ma);
	}
	ans[x].first = max(n-sz[x],ma);
	ans[x].second = x;
}
bool cmp(pair<int,int> a,pair<int,int> b){
		if(a.first == b.first)
			return a.second < b.second;
		else
			return a.first < b.first;
	}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i <= n - 1;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v);
		add(v,u);
	}
	find(0,1);
	sort(ans + 1,ans + 1 + n,cmp);
	int mi = ans[1].first;
	for(int i = 1;i <= n;i++)
		if(mi == ans[i].first)
			printf("%d ",ans[i].second);
	return 0;
}
```

## 用贪心和树上dp解决[树的最小支配集，最小点覆盖与最大独立集](https://www.cnblogs.com/i-love-acm/p/3558238.html)问题

* 最小支配集：对于图$G=(V,E)$来说，选最少的点组成一个集合使得所有点都与集合中的点有边相连

* 最小点覆盖：对于图$G=(V,E)$来说，选最少的点组成一个集合使得所有边都与集合中的点相连
* 最大独立集：对于图$G=(V,E)$来说，选最多的点组成一个集合使得任意集合中的两点不相连

* 贪心法：用dfs给所有节点反向排序，这样就能实现对节点处理时所有子树都被处理过，从而确定贪心的正确性
* DFS确定顺序

```c++
void dfs(int _dad,int x){
    edge* p = head[x];
    while(p != NULL){
        int v = p -> v;
        p = p -> nex;
        if(use[v])
            continue;
       	use[v] = 1;
        dfs(x,v);
    }
    dad[x] = _dad;
    a[++t] = x;
}
```

* 对于最小支配集，贪心方案为从子树开始，如果这个节点没有被标记并且父节点没有被选，为了对后面产生最好的影响，选取父节点，如果标记自己，父节点，父节点的父节点，因为已经用DFS确定过顺序，所以只要考虑父节点即可，子节点已经被标记过

```c++
void greedy(int n){
    for(int i = 1;i <= n;i++){
        int x = a[i];
        if(bj[x] || xz[dad[x]])//已经被标记过或者父节点被选中
            continue;
        else{
            ans++;
            xz[dad[x]] = 1;
            bj[x] = 1;
            bj[dad[x]] = 1;
            bj[dad[dad[x]]] = 1;
        }
    }
}
```

* 对于最小点覆盖，相对于最小支配集，也是要选中父节点来对后面产生最好影响，每次轮到的节点，只有父节点方向的边，所以只要看父节点是否被选中即可，对于根节点，因为没有父节点所以要特判

```c++
void greedy(int n){
    for(int i = 1;i <= n;i++){
        int x = a[i];
        if(xz[x] || xz[dad[x]] || x == dad[x])
            continue;
        else{
            ans++;
            xz[dad[x]] = 1;
        }
    }
}
```

* 对于最大独立集，为了对后面产生最好影响，当这个点没有被标记时就应该直接选中这个点，每次选中这个点时标记自己和父节点

```c++
void greedy(int n){
    for(int i = 1;i <= n;i++){
        int x = a[i];
        if(bj[x])
            continue;
        else{
            ans++;
            bj[dad[x]] = 1;
        }
    }
}
```

* 动态规划法：同贪心法用DFS处理完子树再处理主树

## 树哈希：判断树的同构

### [P5043 【模板】树同构（[BJOI2015]树的同构）](https://www.luogu.com.cn/problem/P5043)

* 拓扑排序，从外到内哈希，在最后一层对每个点都当作根，取最大的哈希作为这棵树的哈希值

```cpp
// xxc
#include<bits/stdc++.h>
using namespace std;

#define endl '\n'
#define IOS ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
#define ll long long
#define debug(x) cout << #x << ' ' << x << endl;

typedef unsigned long long ull;

const ull mask = std::chrono::steady_clock::now().time_since_epoch().count();

const int N = 51;

ull shift(ull x){
	x ^= mask;
	x ^= x << 13;
	x ^= x >> 7;
	x ^= x << 17;
	x ^= mask;
	return x;
}

int in[N];
ull res_hash[N];
ull res_ans[N];

vector<int> ed[N];

int nn;

map<ull,int> mp;

int get_mahash(int no){
	queue<int> qu;
	for(int i = 1;i <= nn;i++){
		if(in[i] == 1) qu.push(i); 
	}
	ull ma = -1;
	while(!qu.empty()){
		int sz = qu.size();
		nn -= sz;
		ull ma = 0;
		queue<int> tem;
		while(sz--){
			int x = qu.front();
			qu.pop();
			tem.push(x);
			in[x] = -1;
			for(auto y : ed[x]){
				in[y]--;
				if(in[y] == 1){
					qu.push(y);
					in[y] = -3;
				}else if(in[y] == -1){
					res_hash[x] += res_hash[y];
				}
			}
		}
		if(qu.size() == 0)//最中间的那些点就是tem里面的点
		{
			while(!tem.empty()){
				int x = tem.front();
				tem.pop();
				ull has = res_hash[x];
				for(auto y : ed[x]){
					if(in[y] != -3) has += res_hash[y];
				}
				has = shift(has);
				ma = max(ma,has);
			}
			res_ans[no] = ma;
			if(mp[ma] == 0) mp[ma] = no;
		}else{
			while(!tem.empty()){
				int x = tem.front();
				in[x] = 0;
				res_hash[x] = shift(res_hash[x]);
				tem.pop();
			}
		}
	}
}

void test(){
	int n;cin >> n;
	for(int j = 1;j <= n;j++){
		cin >> nn;
		for(int i = 1;i <= nn;i++){
			res_hash[i] = 1;
			in[i] = 0;
			ed[i].clear();
		}
		for(int i = 1;i <= nn;i++){
			int fa;cin >> fa;
			if(fa != 0){
				in[fa]++;
				in[i]++;
				ed[fa].push_back(i);
				ed[i].push_back(fa);
			}
		}
		get_mahash(j);
	}
	for(int i = 1;i <= n;i++){
		cout << mp[res_ans[i]] << '\n';
	}
}

int main(){
	IOS
	int t = 1;//cin >> t;
	while(t--){
		test();
	}
}
```

## 点分治

### 处理树上问题，将问题范围分为穿过树根的与子树内部

### 对于子树内部采用递归处理，对穿过树根具体题目具体分析

### 为了让递归层数尽量少，先要找重心

### 找重心：

### 重心为所有子树的最大值最小的节点

### 用$sz[i]$记录点$i$作为父亲子树时的子树数量，每次从父节点到$i$节点时初始化为$1$

### 用$max\_sz[i]$记录节点最大的子树数量，递归处理完所有子树后，用$all-sz[i]$更新$max\_sz[i]$即可得到$i$节点的最大子树节点数量，再更新$zx$即可

### 分治：找重心，计算经过重心的可能性，遍历以重心为根的子树，对那些子树找重心继续递归

### [模板点分治1](https://www.luogu.com.cn/problem/P3806)

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 2e4 + 10,M = 1e2 + 10;
const int INF = 1e7 + 10;

bool vis[N],able[M];
int n,m,zx,idx;
int zs[N],max_zs[N],ask[M];
int d[N],dis[N];
bool judge[INF];

struct edge{
	int v,w;
	edge* nex;
}ed[N*2];
int ptop;
edge* head[N];

void add(int u,int v,int w){
	ed[ptop].v = v;
	ed[ptop].w = w;
	ed[ptop].nex = head[u];
	head[u] = &ed[ptop];
	ptop++;
}

void get(){
	cin >> n >> m;
	for(int i = 1;i <= n - 1;i++){
		int u,v,w;cin >> u >> v >> w;
		add(u,v,w);
		add(v,u,w);
	}
	for(int i = 1;i <= m;i++)
		cin >> ask[i];
}

void get_zx(int u,int fa,int all){
	zs[u] = 1;
	max_zs[u] = 0;
	for(edge* p = head[u];p != NULL;p = p -> nex){
		int v = p -> v;
		if(vis[v] || v == fa) continue;
		get_zx(v,u,all);
		zs[u] += zs[v];
		max_zs[u] = max(max_zs[u],zs[v]);
	}
	max_zs[u] = max(all - zs[u],max_zs[u]); 
	if(max_zs[u] < max_zs[zx])
		zx = u;
}

void get_dis(int u,int fa,int len){
	d[++idx] = len;
	for(edge* p = head[u];p != NULL;p = p -> nex){
		int v = p -> v,w = p -> w;
		if(vis[v] || v == fa) continue;
		get_dis(v,u,len + w);
	}
}

void calc(int x){
	judge[0] = 1;
	stack<int> st;
	for(edge* p = head[x];p != NULL;p = p -> nex){//所有子树
		int v = p -> v,w = p -> w;
		if(vis[v]) continue;
		idx = 0;
		get_dis(v,x,w);//这个子树上的所有距离
		for(int i = 1;i <= idx;i++){
			for(int j = 1;j <= m;j++){
				if(ask[j] - d[i] >= 0 && ask[j] - d[i] < INF && judge[ask[j] - d[i]])
					able[j] = 1;
			}
		}
		for(int i = 1;i <= idx;i++)//处理完成，放入judge
		{
			if(d[i] <= INF){
				judge[d[i]] = 1;
				st.push(d[i]);
			}
		}
	}
	while(!st.empty()){//清空judge
		judge[st.top()] = 0;
		st.pop();
	}
}

void divid(int x){
	calc(x);//计算经过x的
	vis[x] = 1;
	for(edge* p = head[x];p != NULL;p = p -> nex){
		int v = p -> v;
		if(vis[v]) continue;
		zx = 0;
		get_zx(v,x,zs[v]);
		divid(zx);
	}
}

int main(){
	ios::sync_with_stdio(false);//写了using namespace std;
	get();
	zx = 0;
	max_zs[0] = INF;
	get_zx(1,0,n);
	divid(zx);
	for(int i = 1;i <= m;i++){
		if(able[i])
			cout << "AYE" << endl;
		else
			cout << "NAY" << endl;
	}
}
```

### [聪聪可可](https://www.luogu.com.cn/problem/P2634)

### 找所有3倍数的连接（包括本身，ab与ba不同）

### 正常分治，calc时记录0,1,2的数量即可

```cpp
#include<bits/stdc++.h>
using namespace std;

#define ll long long

const int N = 2e4 + 10,INF = 1e9 + 10;

ll gcd(ll a,ll b){
	if(b == 0) return a;
	else return gcd(b,a%b);
}

ll n;
bool vis[N];
int zs[N],max_zs[N],zx;

struct edge{
	int v,w;
	edge* nex;
}ed[N*2];
int ptop;
edge* head[N];
void add(int u,int v,int w){
	ed[ptop].v = v;
	ed[ptop].nex = head[u];
	ed[ptop].w = w;
	head[u] = &ed[ptop++];
}

void get_zx(int u,int fa,int all){
	zs[u] = 1;
	max_zs[u] = 0;
	for(edge* p = head[u];p != NULL;p = p -> nex){
		int v = p -> v;
		if(vis[v] || v == fa) continue;
		get_zx(v,u,all);
		zs[u] += zs[v];
		max_zs[u] = max(max_zs[u],zs[v]);
	}
	max_zs[u] = max(max_zs[u],all - zs[u]);
	if(max_zs[zx] > max_zs[u])
		zx = u;
}

ll num[3],d[3],ans;

void get_dis(int u,int fa,int len){
	d[len]++;
	for(edge* p = head[u];p != NULL;p = p -> nex){
		int v = p -> v,w = p -> w;
		if(vis[v] || v == fa) continue;
		get_dis(v,u,(len + w) % 3);
	}
}

void calc(int u){
	num[1] = num[2] = 0;
	num[0] = 1;
	for(edge* p = head[u];p != NULL;p = p -> nex){
		int v = p -> v,w = p -> w;
		if(vis[v]) continue;
		d[0] = d[1] = d[2] = 0;
		get_dis(v,u,w % 3);
		for(int i = 0;i < 3;i++)
			ans += num[(3 - i) % 3]*d[i];
		for(int i = 0;i < 3;i++)
			num[i] += d[i];
	}
}

void divid(int u){
	calc(u);
	vis[u] = 1;
	for(edge* p = head[u];p != NULL;p = p -> nex){
		int v = p -> v;
		if(vis[v]) continue;
		zx = 0;
		get_zx(v,u,zs[v]);
		divid(zx);
	}
}

void get(){
	cin >> n;
	for(int i = 1;i <= n - 1;i++){
		int u,v,w;cin >> u >> v >> w;
		w %= 3;
		add(u,v,w);
		add(v,u,w);
	}
}

int main(){
	max_zs[0] = INF;
	get();
	zx = 0;
	get_zx(1,0,n);
	divid(zx);
	ll all = n*n;
	ans = ans * 2 + n;
	ll gc = gcd(ans,all);
	cout << ans / gc << '/' << all / gc << endl;
}
```

### [P4178 Tree](https://www.luogu.com.cn/problem/P4178)

### 找树上距离小于k的点对

### 用树状数组维护

```cpp
#include<bits/stdc++.h>
using namespace std;

#define IOS ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
#define lowbit(x) (x&-x)

const int N = 4e4 + 10;

int tr[N / 2];

int k,n;

int num_0 = 0;

void add(int x,int y){
	if(x == 0) num_0 += y;
	for(;x <= k;x += lowbit(x)) tr[x] += y;
}
int query(int x){
	if(x == 0) return num_0;
	int res = 0;
	for(;x;x -= lowbit(x)) res += tr[x];
	return res;
}

struct edge{
	int v,w,nex;
}ed[N*2];
int head[N];
int ptop = 0;
void add(int u,int v,int w){
	ptop++;
	ed[ptop].v = v;
	ed[ptop].w = w;
	ed[ptop].nex = head[u];
	head[u] = ptop;
}

int fa[N],sz[N];
bool vis[N];

int zx,misz;
void get_zx(int u,int dad,int all){
	if(u == dad){
		misz = all;
		zx = u;
	}
	sz[u] = 1;
	int x = 0;
	for(int p = head[u];p;p = ed[p].nex){
		if(ed[p].v == dad) continue;
		sz[u] += sz[ed[p].v];
		x = max(x,sz[ed[p].v]);
	}
	x = max(all - sz[u],x);
	if(x < misz) zx = u;
}

int idx;
int d[N];

void get_dis(int u,int fa,int len){
	d[++idx] = len;
	for(int p = head[u];p;p = ed[p].nex){
		if(ed[p].v == fa || vis[ed[p].v]) continue;
		get_dis(ed[p].v,u,len + ed[p].w);
	}
}

int ans = 0;

void calc(int x){
	stack<int> st;
	for(int p = head[x];p;p = ed[p].nex){
		if(vis[ed[p].v]) continue;
		idx = 0;
		get_dis(ed[p].v,x,ed[p].w);
		for(int i = 1;i <= idx;i++){
			if(d[i] <= k) ans += query(k - d[i]);
		}
		for(int i = 1;i <= idx;i++) if(d[i] <= k) add(d[i],1),st.push(d[i]),ans++;
	}
	while(!st.empty()){
		add(st.top(),-1);
		st.pop();
	}
}

void divid(int x){
	calc(x);
	vis[x] = 1;
	for(int p = head[x];p;p = ed[p].nex){
		if(vis[ed[p].v]) continue;
		zx = 0;
		get_zx(ed[p].v,ed[p].v,sz[ed[p].v]);
		divid(zx);
	}
}

int main(){
	IOS
	cin >> n;
	for(int i = 1;i < n;i++){
		int u,v,w;cin >> u >> v >> w;
		add(u,v,w);
		add(v,u,w);
	}
	cin >> k;
	get_zx(1,1,n);
	divid(zx);
	cout << ans << endl;
}
```

## 虚树

### 对于树上dp来说，如果每次询问所涉及的点较少，那么树上有许多点都是没有必要遍历的，那么我们就要建一颗新的只跟所涉及的点有关的树来进行树上dp即可大大降低复杂度

### 假设新树的点为关键点，那么我们就可以得出以下结论

* 询问所涉及的点肯定为关键点
* 关键点间的lca也为关键点
* 所建的新树与原树的祖先后代关系相同

### 关于复杂度证明，可得到虚树点的总数不超过所涉及的点的两倍（意会一下）

### 那么通过dfs序与lca来建虚树即可

### 步骤：

* 1.建原树，dfs得出倍增父节点，dfs序，dep
* 2.给所涉及的点根据dfs序来排序
* 用栈来建虚树
* 3.将点1先放入栈中
* 4.记录lc为要放入的点与栈顶元素的最近公共祖先
* 5.从栈顶开始删去深度比lc大的点，并连上相邻的点
* 6.如果lc不在栈内，加入栈中，并连上本次循环中最后一个踢掉的点
* 7.直到所有点放入虚树中
* 8.根据虚树dp
* 注意初始化、清空等等

### [P2495 [SDOI2011] 消耗战](https://www.luogu.com.cn/problem/P2495)

#### 题意：可以花费一定代价使得边中断，问使得点1无法到达任意一个标记点的最小代价

#### 思路：记录所有点向上跳$2^k$所经历的最小边，建立虚树，询问是就看虚树两点间的最小边来进行dp即可，用$dp[i]$代表这个点与下面被标记的点不相连的最小代价，那么如果子树那个点被标记，那么直接加该点到子树的最小边，否则加上子树点的dp与该点到子树的最小边的最小值

```cpp
// xxc
#include<bits/stdc++.h>
using namespace std;

#define endl '\n'
#define IOS ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
#define ll long long
#define debug(x) cout << #x << ' ' << x << endl;

const int N = 2.5e5 + 10,inf = 1e9 + 10;
const ll INF = 1e18 + 10;

struct point{
	int fa[20],dfs,dep;
	int w[20];//向上跳2^i的最短边
}p[N];

struct edge{//原树与虚树
	int w;
	int v,nex;
}ed[N*2],ved[N*2];
int head[N],vhead[N];
int ptop = 0,vptop = 0;
void add(int u,int v,int w){
	ptop++;
	ed[ptop].v = v;
	ed[ptop].w = w;
	ed[ptop].nex = head[u];
	head[u] = ptop;
}
void vadd(int u,int v){
	vptop++;
	ved[vptop].v = v;
	ved[vptop].nex = vhead[u];
	vhead[u] = vptop;
}

int _dfs = 0;
void dfs(int x,int dad){
	p[x].dep = p[dad].dep + 1;
	p[x].dfs = ++_dfs;
	p[x].fa[0] = dad;
	for(int i = 1;i <= 19;i++) p[x].fa[i] = p[p[x].fa[i - 1]].fa[i - 1];
	for(int i = 1;i <= 19;i++) p[x].w[i] = min(p[p[x].fa[i - 1]].w[i - 1],p[x].w[i - 1]);
	for(int por = head[x];por;por = ed[por].nex){
		if(ed[por].v == dad) continue;
		p[ed[por].v].w[0] = ed[por].w;
		dfs(ed[por].v,x);
	}
}

int lca(int x,int y){
	if(p[x].dep > p[y].dep) swap(x,y);
	for(int i = 19;i >= 0;i--){
		if(p[p[y].fa[i]].dep >= p[x].dep) y = p[y].fa[i];
	}
	if(x == y) return x;
	for(int i = 19;i >= 0;i--){
		if(p[x].fa[i] != p[y].fa[i]){
			x = p[x].fa[i];
			y = p[y].fa[i];
		}
	}
	return p[x].fa[0];
}

ll w(int x,int y){//x与y竖直链上的最短边
	if(p[x].dep > p[y].dep) swap(x,y);
	int ans = inf;
	for(int i = 19;i >= 0;i--){
		if(p[p[y].fa[i]].dep >= p[x].dep){
			ans = min(ans,p[y].w[i]);
			y = p[y].fa[i];
		}
	}
	return ans;
}

bool cmp(int i,int j){
	return p[i].dfs < p[j].dfs;
}

int h[N];

int k;

int st[N];

int pptop = 0;
int use[N];
void build_vtr(){//造虚树
	sort(h + 1,h + 1 + k,cmp);
	vptop = 0;
	pptop = ptop = 1;
	use[1] = st[1] = 1;
	for(int i = 1;i <= k;i++){
		int lc = lca(h[i],st[ptop]);
		while(p[lc].dep < p[st[ptop]].dep){
			ptop--;
			if(p[lc].dep < p[st[ptop]].dep)
				vadd(st[ptop],st[ptop + 1]);
			else
				vadd(lc,st[ptop + 1]);
		}
		if(lc != st[ptop])
			st[++ptop] = use[++pptop] = lc;
		use[++pptop] = st[++ptop] = h[i];
	}
	while(--ptop){
		vadd(st[ptop],st[ptop + 1]);
	}
}

ll dp[N];
bool ned[N];
void dfs_vtr(int x){
	for(int por = vhead[x];por;por = ved[por].nex){
		dfs_vtr(ved[por].v);
		if(ned[ved[por].v]){
			dp[x] = dp[x] + w(x,ved[por].v);
			ned[ved[por].v] = 0;
		}
		else
			dp[x] = dp[x] + min(dp[ved[por].v],w(x,ved[por].v));
	}
	vhead[x] = 0;
}

void init(int n){
	for(int i = 0;i <= 19;i++) p[1].w[i] = inf;
}

void test(){
	int n;cin >> n;
	init(n);
	for(int i = 1;i < n;i++){
		int u,v,w;cin >> u >> v >> w;
		add(u,v,w);
		add(v,u,w);
	}
	dfs(1,1);
	int m;cin >> m;
	for(int i = 1;i <= m;i++){
		cin >> k;
		for(int i = 1;i <= k;i++){
			cin >> h[i];
			ned[h[i]] = 1;//标记关键点
		}
		build_vtr();
		dfs_vtr(1);
		cout << dp[1] << endl;
		for(int i = 1;i <= pptop;i++) dp[use[i]] = 0;
	}
}

int main(){
//	IOS
	int t = 1;//cin >> t;
	while(t--){
		test();
	}
}
```

## 树上启发式合并

### 复杂度$O(nlog_2n)$考虑所有子树

### 继承大子树，取消小子树

### 步骤：

* 1.找重儿子，确认dfs序，记录sz，记录rk
* 2.遍历轻子，统计答案，但不继承cnt（dfs下去）
* 3.跑重子，统计答案，继承cnt（dfs下去）
* 4.遍历轻子继承cnt（dfs序遍历）

### [U41492 树上数颜色](https://www.luogu.com.cn/problem/U41492)

### 题意：问每个子树的颜色数

```cpp
// xxc
#include<bits/stdc++.h>
using namespace std;

#define endl '\n'
#define IOS ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
#define ll long long
#define debug(x) cout << #x << ' ' << x << endl;

const int N = 1e5 + 10;

vector<int> ed[N];

int rk[N];

struct point{
    int cnt,c,dfs,sz,son;
}p[N];

int total = 0;

void add(int x){
	cnt[c[x]]++;
	if(cnt[c[x]] == 1) total++;
}
void del(int x){
	cnt[c[x]]--;
	if(cnt[c[x]] == 0) total--;
}

int _dfs = 0;
void dfs0(int x,int dad){
	sz[x] = 1;
	ldfs[x] = ++_dfs;
	rk[_dfs] = x;
	int mai = 0;
	for(auto y : ed[x]){
		if(y == dad) continue;
		dfs0(y,x);
		if(sz[mai] < sz[y]) mai = y;
		sz[x] += sz[y];
	}
	son[x] = mai;
}

int ans[N];

void dfs1(int x,int dad,bool flag){
	for(auto y : ed[x]){
		if(y != son[x] && y != dad)
			dfs1(y,x,0);
	}
	if(son[x])
		dfs1(son[x],x,1);
	for(auto y : ed[x]){
		if(y != son[x] && y != dad){
			for(int i = ldfs[y];i <= ldfs[y] + sz[y] - 1;i++){
				add(rk[i]);
			}
		}
	}
	add(x);
	ans[x] = total;
	if(!flag){
		for(int i = ldfs[x];i <= ldfs[x] + sz[x] - 1;i++){
			del(rk[i]);
		}
	}
}

void test(){
	int n;cin >> n;
	for(int i = 1;i < n;i++){
		int u,v;cin >> u >> v;
		ed[u].push_back(v);
		ed[v].push_back(u);
	}
	for(int i = 1;i <= n;i++) cin >> c[i];
	dfs0(1,0);
	dfs1(1,0,0);
	int m;cin >> m;
	for(int i = 1;i <= m;i++){
		int x;cin >> x;
		cout << ans[x] << endl;
	}
}

int main(){
	IOS
	int t = 1;//cin >> t;
	while(t--){
		test();
	}
}
```

### [E. Lomsat gelral](https://codeforces.com/problemset/problem/600/E)

### 题意：问每个子树中没有比该种颜色节点数量更多的颜色数量

```cpp
// xxc
#include<bits/stdc++.h>
using namespace std;

#define endl '\n'
#define IOS ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
#define ll long long
#define debug(x) cout << #x << ' ' << x << endl;

const int N = 1e5 + 10;

vector<int> ed[N];

int cnt[N];
int num[N];//记录cnt为i的数量
ll sum[N];
int ma = 0;

void add(int x){
	if(cnt[x] == ma) ma++;
	sum[cnt[x]] -= x;
	num[cnt[x]]--;
	cnt[x]++;
	num[cnt[x]]++;
	sum[cnt[x]] += x;
}
void del(int x){
	if(cnt[x] == ma && num[cnt[x]] == 1) ma--;
	sum[cnt[x]] -= x;
	num[cnt[x]]--;
	cnt[x]--;
	num[cnt[x]]++;
	sum[cnt[x]] += x;
}

int rk[N];

struct point{
	int sz,dfs,son,c;
}p[N];

int _dfs = 0;

void dfs0(int x,int dad){
	p[x].dfs = ++_dfs;
	rk[_dfs] = x;
	p[x].sz = 1;
	int mai = 0;
	for(auto y : ed[x]){
		if(y == dad) continue;
		dfs0(y,x);
		p[x].sz += p[y].sz;
		if(p[mai].sz < p[y].sz) mai = y;
	}
	p[x].son = mai;
}

ll ans[N];

void dfs1(int x,int dad,bool f){
	for(auto y : ed[x]){
		if(y != dad && y != p[x].son)
			dfs1(y,x,0);
	}
	if(p[x].son)
		dfs1(p[x].son,x,1);
	for(auto y : ed[x]){
		if(y != dad && y != p[x].son){
			for(int j = p[y].dfs;j <= p[y].dfs + p[y].sz - 1;j++)
				add(p[rk[j]].c);
		}
	}
	add(p[x].c);
	ans[x] = sum[ma];
	if(!f){
		for(int i = p[x].dfs;i <= p[x].dfs + p[x].sz - 1;i++){
			del(p[rk[i]].c);
		}
	}
}

void test(){
	int n;cin >> n;
	for(int i = 1;i <= n;i++) cin >> p[i].c;
	for(int i = 1;i < n;i++){
		int x,y;cin >> x >> y;
		ed[x].push_back(y);
		ed[y].push_back(x);
	}
	dfs0(1,0);
	dfs1(1,0,0);
	for(int i = 1;i <= n;i++)
		cout << ans[i] << ' ';
}

int main(){
	IOS
	int t = 1;//cin >> t;
	while(t--){
		test();
	}
}
```

## 支配树

### 定义：

* 对于一个单一起点有向图而言，如果去掉了点x，就无法到达y，那么称x为y的支配点

* 在y的支配点集中，如果x被除自己以外的点支配，那么称x为y的最近支配点，记作$x=idom[y]$
* 构造树$e[idom[i],i](i\neq root)$称为支配树

### 有向无环图(DAG)支配树建立方法：

* 一个点的$idom$为能到它的所有点的共同最近公共祖先，因此用拓扑排序让点x遍历时所有能到达该点x的y均遍历过
* 建图，记录每个点的入度
* 拓扑排序
* 遍历u能到的所有v
* 如果v是第一次访问，那么令它的$idom[v]$为$u$，否则$idom[v]=lca(idom[v],u)$
* 如果v的入度变成0，给支配树加入边$add(idom[v],v)$，记录$fa[v] [0]=idom[v]$，维护$lca$，将$v$加入队列中
* 复杂度：$O(nlog_2n+mlog_2m)$
* 例题[P2597 [ZJOI2012] 灾难](https://www.luogu.com.cn/problem/P2597)

```cpp
#include<bits/stdc++.h>
using namespace std;

#define IOS ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);

const int N = 65535,M = 1e7 + 10;

int fa[N][20],n,in[N],dep[N],idom[N],ans[N];
bool vis[N];

struct edge{
	int v,to;
}ed[M],ne[M];
int head[N],nhead[N];
int ptop = 0;
void add(int u,int v){
	ptop++;
	ed[ptop].v = v;
	ed[ptop].to = head[u];
	head[u] = ptop;
}

void addne(int u,int v){
	ptop++;
	ne[ptop].v = v;
	ne[ptop].to = nhead[u];
	nhead[u] = ptop;
}

int lca(int x,int y){
	if(dep[x] < dep[y]) swap(x,y);
	for(int i = 19;i >= 0;i--) if(dep[fa[x][i]] >= dep[y]) x = fa[x][i];
	if(x == y) return x;
	for(int i = 19;i >= 0;i--) if(fa[x][i] != fa[y][i]) x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}

void tp(){
	ptop = 0;
	queue<int> qu;
	for(int i = 1;i <= n;i++){
		if(in[i] == 0){
			qu.push(i);
			idom[i] = 0;
			fa[i][0] = 0;//超级源点
			addne(0,i);
			dep[i] = 1;
		}	
	}
	while(!qu.empty()){
		int u = qu.front();qu.pop();
		for(int p = head[u];p;p = ed[p].to){
			int v = ed[p].v;
			in[v]--;
			if(!vis[v])
				idom[v] = u;
			vis[v] = 1;
			idom[v] = lca(idom[v],u);
			if(in[v] == 0){
				addne(idom[v],v);
				fa[v][0] = idom[v];
				for(int i = 1;i < 20;i++)
					fa[v][i] = fa[fa[v][i - 1]][i - 1];
				dep[v] = dep[idom[v]] + 1;
				qu.push(v);
			}
		}
	}
}



void dfs(int x){
	ans[x] = 1;
	for(int p = nhead[x];p;p = ne[p].to){
		int v = ne[p].v;
		dfs(v);
		ans[x] += ans[v];
	}
}

int main(){
	IOS
	cin >> n;
	for(int i = 1;i <= n;i++){
		int x;cin >> x;
		while(x != 0){
			add(x,i);
			in[i]++;
			cin >> x;
		}
	}
	tp();
	dfs(0);
	for(int i = 1;i <= n;i++)
		cout << ans[i] - 1 << endl;
}
```

### 有向有环图的支配树：

* 求dfs序，同时构造dfs树，记录每个节点dfs时的父节点
* 求sdom，从dfs大的开始，除原点，枚举反向边，如果dfs序小采用，否则采用祖先(mn)的sdom的dfs小的，用带权并查集维护，注意维护时要先find(fa[x])再维护
* 根据dfs树与sdom构造的DAG图求支配树
* 统计答案
* [P5180 【模板】支配树](https://www.luogu.com.cn/problem/P5180)

```cpp
//#pragma GCC optimize(2)
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define IOS ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
#define debug(x) cout << #x << '=' << x << endl;

inline int Min(int x,int y){return x > y ? y : x;}
inline int Max(int x,int y){return x > y ? x : y;}

const int N = 3e5 + 10,M = 4e5 + 10;

int dfs[N],sdom[N],idom[N],dep[N],fa[N][20],rdfs[N],in[N],dad[N],anc[N],mn[N],ans[N];
int n,m;
bool vis[N];
struct {
	int v,to;
}e[3][M];
int ptop[3];
int h[3][N];

void init(){
	for(int i = 1;i <= n;i++)
		sdom[i] = dad[i] = mn[i] = i;
}

void add(int u,int v,int t){
	ptop[t]++;
	e[t][ptop[t]].to = h[t][u];
	e[t][ptop[t]].v = v;
	h[t][u] = ptop[t];
}

int _dfs;
void dfs1(int x){//求出dfs序
	dfs[x] = ++_dfs;
	rdfs[_dfs] = x;
	for(int p = h[0][x];p;p = e[0][p].to){
		int y = e[0][p].v;
		if(!dfs[y]){
			anc[y] = x;
			add(x,y,2);
			in[y]++;
			dfs1(y);
		}
	}
}

int find(int x){//带权并查集
	if(x == dad[x]) return x;
	int tem = dad[x];dad[x] = find(dad[x]);
	if(dfs[sdom[mn[x]]] > dfs[sdom[mn[tem]]]) mn[x] = mn[tem];
	return dad[x];
}

int lca(int x,int y){
	if(dep[x] < dep[y]) swap(x,y);
	for(int i = 19;i >= 0;i--) if(dep[fa[x][i]] >= dep[y]) x = fa[x][i];
	if(x == y) return x;
	for(int i = 19;i >= 0;i--) if(fa[x][i] != fa[y][i]) x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}

void getsdom(){
	for(int i = _dfs;i >= 2;i--){
		int x = rdfs[i],res = n;
		for(int p = h[1][x];p;p = e[1][p].to){
			int y = e[1][p].v;
			if(!dfs[y]) continue;
			find(y);
			if(dfs[y] < dfs[x]) res = Min(res,dfs[y]);
			else res = Min(res,dfs[sdom[mn[y]]]);
		}
		sdom[x] = rdfs[res];
		add(sdom[x],x,2);
		in[x]++;
		dad[x] = anc[x];
	}
}

void tp(){
	memset(h[0],0,sizeof(h[0]));
	ptop[0] = 0;
	queue<int> qu;
	for(int i = 1;i <= n;i++){
		if(in[i] == 0){
			idom[i] = 0;
			dep[i] = 1;
			fa[i][0] = 0;
			qu.push(i);
			add(0,i,0);
		}
	}
	while(!qu.empty()){
		int u = qu.front();qu.pop();
		for(int p = h[2][u];p;p = e[2][p].to){
			int v = e[2][p].v;
			if(!vis[v]) idom[v] = u;
			idom[v] = lca(idom[v],u);
			vis[v] = 1;
			in[v]--;
			if(in[v] == 0){
				qu.push(v);
				fa[v][0] = idom[v];
				for(int i = 1;i < 20;i++) fa[v][i] = fa[fa[v][i - 1]][i - 1];
				dep[v] = dep[idom[v]] + 1;
				add(idom[v],v,0);
			}
		}
	}
}

void dfs2(int x){
	ans[x] = 1;
	for(int p = h[0][x];p;p = e[0][p].to){
		int y = e[0][p].v;
		dfs2(y);
		ans[x] += ans[y];
	}
}

void Lengauer_Tarjan(){
	init();
	dfs1(1);
	getsdom();
	tp();
	dfs2(0);
}

int main(){
	IOS
	cin >> n >> m;
//	for(int i = 1;i <= n;i++){
//		int x;cin >> x;
//		while(x){
//			add(x,i,2);
//			in[i]++;
//			add(i,x,1);
//			cin >> x;
//		}
//	}
	for(int i = 1,i <= m;i++){
		int u,v;cin >> u >> v;
		add(u,v,0);
		add(v,u,1);
	}
	Lengauer_Tarjan();
	for(int i = 1;i <= n;i++)
		cout << ans[i] << ' ';
}
```

## 换根

### 用于解决树上假设每个点均为根的问题

### 思路：跑两遍dfs，第一遍假设一个节点为根，第二遍根据上一遍跑的尝试计算父节点的贡献并得出所有节点为根的情况

### 第二遍dfs一般思路为：如果为根节点，那么记录，否则将父节点纳入考虑中

### 在遍历所有子节点前记录现在的数据，要遍历那个子节点就取消该子节点的数据对该数据的影响再继续dfs，然后还原到原来的数据

### [P3478 [POI2008] STA-Station](https://www.luogu.com.cn/problem/P3478)

#### 题意：以一个节点为根使得所有节点深度之和最大

#### 思路：维护以该节点为子节点的节点数量与总深度

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define IOS ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);

const int N = 1e6 + 10;

vector<int> ed[N];

ll cnt[N],sumdep[N];

void dfs1(int son,int dad){
	cnt[son] = 1;
	for(auto v:ed[son]){
		if(v == dad) continue;
		dfs1(v,son);
		cnt[son] += cnt[v];
		sumdep[son] += cnt[v] + sumdep[v];
	}
}

pair<ll,ll> ans;

void dfs2(int son,int dad){
	if(son == 1){
		ans = {sumdep[1],1};
	}else{
		sumdep[son] += cnt[dad] + sumdep[dad];
		cnt[son] += cnt[dad];
		if(sumdep[son] > ans.first)
			ans = {sumdep[son],son};
	}
	ll rescnt = cnt[son],ressum = sumdep[son];
	for(auto v:ed[son]){
		if(v == dad) continue;
		cnt[son] -= cnt[v];
		sumdep[son] -= cnt[v] + sumdep[v];
		dfs2(v,son);
		cnt[son] = rescnt;
		sumdep[son] = ressum;
	}
}

int main(){
	IOS
	int n;cin >> n;
	for(int i = 1;i < n;i++){
		int u,v;cin >> u >> v;
		ed[u].push_back(v);
		ed[v].push_back(u);
	}
	dfs1(1,1);
	dfs2(1,1);
	cout << ans.second << endl;
}
```

## [P2986 [USACO10MAR] Great Cow Gathering G](https://www.luogu.com.cn/problem/P2986)

#### 题意：n个牛棚，n-1条路，每个牛棚有$C_i$只牛，不方便的程度为$\sum _{i-1}^nC_idis_i$，$dis_i$为根到该点的距离，问最小的不方便值为多少

#### 思路：维护牛的数量，总不方便值

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define IOS ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);

const int N = 1e5 + 10;
ll cnt[N],sum[N],c[N];

vector<pair<int,int>> ed[N];

void dfs1(int son,int dad){
	cnt[son] += c[son];
	for(auto pa:ed[son]){
		int v = pa.first,dis = pa.second;
		if(v == dad) continue;
		dfs1(v,son);
		cnt[son] += cnt[v];
		sum[son] += sum[v] + cnt[v] * dis;
	}
}

ll ans;

void dfs2(int son,int dad,ll dis){
	if(son == 1){
		ans = sum[son];
	}else{
		cnt[son] += cnt[dad];
		sum[son] += cnt[dad] * dis + sum[dad];
		ans = min(sum[son],ans);
	}
	ll rescnt = cnt[son],ressum = sum[son];
	for(auto pa:ed[son]){
		int v = pa.first,_dis = pa.second;
		if(v == dad) continue;
		cnt[son] -= cnt[v];
		sum[son] -= cnt[v] * _dis + sum[v];
		dfs2(v,son,_dis);
		cnt[son] = rescnt;
		sum[son] = ressum;
	}
}

int main(){
	IOS
	int n;cin >> n;
	for(int i = 1;i <= n;i++)
		cin >> c[i];
	for(int i = 1;i < n;i++){
		int a,b,l;cin >> a >> b >> l;
		ed[a].push_back({b,l});
		ed[b].push_back({a,l});
	}
	dfs1(1,1);
	dfs2(1,1,0);
	cout << ans << endl;
}
```

### [E. Tree Painting](https://codeforces.com/problemset/problem/1187/E)

#### 题意：给定一棵n个点的树 初始全是白点

#### 要求你做n步操作，每一次选定一个与一个黑点相隔一条边的白点，将它染成黑点，然后获得该白点被染色前所在的白色联通块大小的权值。

#### 第一次操作可以任意选点。

#### 求可获得的最大权值

#### 思路：维护数量与答案

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define IOS ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);

const int N = 2e5 + 10;
ll cnt[N],sum[N];
vector<int> ed[N];

ll ans;
void dfs1(int son,int dad){
	cnt[son] = 1;
	for(auto v:ed[son]){
		if(v == dad) continue;
		dfs1(v,son);
		cnt[son] += cnt[v];
		sum[son] += cnt[v] + sum[v];
	}
}

void dfs2(int son,int dad){
	if(son == 1){
		ans = sum[1];
	}else{
		sum[son] += cnt[dad] + sum[dad];
		cnt[son] += cnt[dad];
		ans = max(sum[son],ans);
	}
	ll ressum = sum[son],rescnt = cnt[son];
	for(auto v:ed[son]){
		if(v == dad) continue;
		sum[son] -= sum[v] + cnt[v];
		cnt[son] -= cnt[v];
		dfs2(v,son);
		sum[son] = ressum;
		cnt[son] = rescnt;
	}
}

int main(){
	IOS
	int n;cin >> n;
	for(int i = 1;i < n;i++){
		int u,v;cin >> u >> v;
		ed[u].push_back(v);
		ed[v].push_back(u);
	}
	dfs1(1,1);
	dfs2(1,1);
	cout << ans + n << endl;
}
```

## 二叉树的读取顺序

### 前序：父节点-->左节点-->右节点

### 中序：左节点-->父节点-->右节点

### 后序：左节点-->右节点-->父节点

### 如何通过两种排序得出第三种排序

* 分治，先找父节点(只可能为一个)，通过这个判断左节点和右节点
* 已知中序和后续，求前序

```c++
#include<bits/stdc++.h>
using namespace std;
string mid,back;
void f(int mid_l,int mid_r,int back_l,int back_r)
{
    int i;
    if(mid_l>mid_r)
        return;
    for(i = 0;i <= 8;i++)
        if(mid[mid_l+i] == back[back_r])
            break;
    cout << mid[mid_l+i];
    f(mid_l,mid_l+i-1,back_l,back_l+i-1);
    f(mid_l+i+1,mid_r,back_l+i,back_r-1);
}
int main()
{
	cin >> mid >> back;
	f(0,mid.size() - 1,0,mid.size() - 1);
}
```

* 已知先序和后序，求中序

```c++
    void f(int x_l,int x_r,int y_l,int y_r,vector<int>& pre,vector<int>& suf,vector<int>& output)
        {
            if(x_l > x_r)
                return;
            else if(x_l==x_r)
                output.push_back(pre[x_l]);
            else
            {
                int num = 1;
                while(pre[x_l+1] != suf[y_l+num-1])
                    num++;
                f(x_l+1,x_l+num,y_l,y_l+num-1,pre,suf,output);
                output.push_back(pre[x_l]);
                f(x_l+num+1,x_r,y_l+num,y_r-1,pre,suf,output);
            }
        }
    vector<int> solve(int n, vector<int>& pre, vector<int>& suf) {
        // write code here
        vector<int> output;
        f(0,n-1,0,n-1,pre,suf,output);
        return output;
    }
```

* 对于已知中序来说，知道父节点就可以知道左右节点的数量，然后进行递归
* 对于不知道中序来说，要通过子节点的父节点位置在最前面和最后面进行判断

## 最小生成树

### 定义

* 边权和最小的生成树

### Kruskal 算法

* 让边从小到大排序，如果不在同一集合，就加入

```c++
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 5e3 + 10,MAXM = 2e5 + 10;
int n,m;
int a[MAXN];
int find(int x)
{
	if(a[x] == x) return x;
	else return a[x] = find(a[x]);
}
struct edge{
	int u,v,val;
}ed[MAXM];
bool cmp(edge a,edge b)
{
	return a.val < b.val;
}
int sum;
void pre()
{
	for(int i = 1;i <= n;i++)
	a[i] = i;
}
void Kruskal()
{
	pre();
	sum = 0;
	for(int i = 1;i <= m;i++)
	{
		if(find(ed[i].u) != find(ed[i].v))
		{
			sum += ed[i].val;
			a[find(ed[i].u)] = find(ed[i].v);
		}
	}
}
int main()
{
	cin >> n >> m;
	for(int i = 1;i <= m;i++)
	{
		cin >> ed[i].u >> ed[i].v >> ed[i].val;
	}
	sort(ed + 1,ed + 1 + m,cmp);
	Kruskal();
	bool flag = true;
	for(int i = 2;i <= n;i++)
	if(find(i) != find(i - 1))
	flag = false;
	if(flag)
	cout << sum;
	else
	cout << "orz";
}
```

### Prim算法

* 搜索，对查到的边排序，取最小的边，加入

```c++
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 5e3 + 10,MAXM = 2e5 + 10;
int n,m;
struct edge{
	int v,val;
	edge* nex;
}ed[MAXM*2];
edge* head[MAXN];
int ptop = 0;
void add_edge(int u,int v,int val)
{
	ed[ptop].v = v,ed[ptop].val = val;
	ed[ptop].nex = head[u];
	head[u] = &ed[ptop];
	ptop++;
}
int sum = 0;
struct cmp{
	bool operator()(const pair<int,int>& a,const pair<int,int>& b)const{
		return a.second > b.second;
	}
};
priority_queue<pair<int,int>,vector<pair<int,int>>,cmp> pq;
bool use[MAXN];
int num = 0;
void Prim()
{
	pq.push({1,0});//距离点1距离为0
	while(!pq.empty() && num < n)
	{
		int x = pq.top().first,val = pq.top().second;
		pq.pop();
		if(use[x]) continue;
		use[x] = 1;//标记
		num++;
		sum += val;
		edge* p = head[x];
		while(p != NULL)
		{
			int y = p -> v,val = p -> val;
			pq.push({y,val});
			p = p -> nex;
		}
	}
}
int main()
{
	cin >> n >> m;
	for(int i = 1;i <= m;i++)
	{
		int x,y,val;cin >> x >> y >> val;
		add_edge(x,y,val);
		add_edge(y,x,val);
	}
	Prim();
	if(num != n)
	cout << "orz";
	else
	cout << sum;
}
```

## 次小生成树

### 定义：边权之和大于最小生成树边权之和的生成树中最小的一个

### 思路：枚举所有未连接的边连上，那么一定会出现一个环，再去掉环上最大的边（如果与新加的边等大就要去次小边），这个最小值就为次小生成树的值

### 朴素求法：先用kruskal求出最小生成树，然后从每个点开始找到其他点的最大边与次大边，然后枚举所有边

### 复杂度$O(n^2+m)$

### LAC优化：就是只讨论一棵树，对每个点记录向上跳$2^i$经过的最大边与次大边

### 注意LAC的i=0时的特殊处理

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int,int>
#define fi first
#define se second
const int N = 1e5 + 10,M = 3e5 + 10;
int n,m,sum;

vector<PII> ed[N];//新图
struct edge{int u,v,len;
bool operator<(const edge &x)const{return len < x.len;}};
edge _ed[M];//旧图
int pre[N];//并查集
bool use[M];//边使用
void init(){for(int i = 1;i <= n;i++) pre[i] = i;}//并查集初始化
int find(int x){if(pre[x] == x) return pre[x];else return pre[x] = find(pre[x]);}
void kruskal(){
	init();
	sort(_ed + 1,_ed + 1 + m);
	for(int i = 1;i <= m;i++){
		if(find(_ed[i].u) != find(_ed[i].v)){
			use[i] = 1;
			sum += _ed[i].len;
			pre[find(_ed[i].u)] = find(_ed[i].v);
			ed[_ed[i].u].push_back({_ed[i].v,_ed[i].len});
			ed[_ed[i].v].push_back({_ed[i].u,_ed[i].len});
		}
	}
}

int dep[N],fa[N][21] = {0};
PII ma[N][21];
void bfs(){
	queue<int> qu;
	qu.push(1);
	dep[1] = 1;
	while(!qu.empty()){
		int u = qu.front();
		qu.pop();
		for(auto e:ed[u]){
			int v = e.fi,len = e.se;
			if(dep[v]) continue;
			qu.push(v);
			dep[v] = dep[u] + 1;
			fa[v][0] = u;
			ma[v][0].fi = len,ma[v][0].se = -1;
			for(int i = 1;i <= 20;i++){
				int faa = fa[v][i - 1];
				fa[v][i] = fa[faa][i - 1];
				ma[v][i].fi = max(ma[v][i-1].fi,ma[faa][i-1].fi);
				if(ma[v][i-1].fi == ma[faa][i-1].fi) ma[v][i].se = max(ma[v][i-1].se,ma[faa][i-1].se);
				else ma[v][i].se = min(ma[v][i-1].fi,ma[faa][i-1].fi);
			}
		}
	}
}

int d[N];
int lca(int x,int y,int w){
	int idx = 0;
	if(dep[x] < dep[y]) swap(x,y);//让x深度更深
	for(int i = 20;i >= 0;i--){//到同一深度
		if(dep[fa[x][i]] >= dep[y]){
			d[++idx] = ma[x][i].fi;
			d[++idx] = ma[x][i].se;
			x = fa[x][i];
		}
	}
	if(x != y){
		for(int i = 20;i >= 0;i--){
			if(fa[x][i] != fa[y][i] || i == 0){
				d[++idx] = ma[x][i].fi;
				d[++idx] = ma[x][i].se;
				d[++idx] = ma[y][i].fi;
				d[++idx] = ma[y][i].se;
				x = fa[x][i];
				y = fa[y][i];
				if(i == 0 && x != y)
				    i++;
			}
		}
	}
	int ma = -1;
	for(int i = 1;i <= idx;i++)
		if(d[i] != w && d[i] > ma) ma = d[i];
	if(ma == -1)
		return 1e18;
	return - ma + w;
}

signed main(){
	cin >> n >> m;
	for(int i = 1;i <= m;i++){
		int x,y,z;cin >> x >> y >> z;
		_ed[i] = {x,y,z};
	}
	kruskal();
	bfs();
	int ans = 1e18;
	for(int i = 1;i <= m;i++){
		if(use[i]) continue;
		ans = min(ans,sum + lca(_ed[i].u,_ed[i].v,_ed[i].len));
	}
	cout << ans << endl;
}
```

## 基环树

### 简单无向图有n个点n-1条边，那么它们会连成一条直线

### n个点n条边，相对多一条边，有且仅有一个环

### 可以利用拓扑排序找这个环

### 例题：[F - Well-defined Path Queries on a Namori](https://atcoder.jp/contests/abc266/tasks/abc266_f?lang=en)

#### 题意：基环树上判断两点之间是否路径唯一

```c++
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 2e5 + 10,MAXM = 2e5 + 10;
int n,q;
struct edge{
	int v;
	edge* nex;
}ed[MAXM * 2];
edge* head[MAXN];
int ptop = 0;
void add(int u,int v)
{
	ed[ptop].v = v;
	ed[ptop].nex = head[u];
	head[u] = &ed[ptop];
	ptop++;
}
int du[MAXN];
bool unable[MAXN];
int co = 1;//颜色
int color[MAXN];
void tp()//拓扑排序,找环
{
	queue<int> qu;
	for(int i = 1;i <= n;i++)
		if(du[i] == 1)
			qu.push(i);
	while(!qu.empty())
	{
		int u = qu.front();qu.pop();
		unable[u] = 1;
		edge* p = head[u];
		while(p != NULL)
		{
			int v = p -> v;
			du[v]--;
			if(du[v] == 1)
				qu.push(v);
			p = p -> nex;
		}
	}
}
bool use[MAXN];
void dfs(int c,int p)//染色
{
	if(use[p] || !unable[p])
		return;
	use[p] = 1;
	color[p] = c;
	edge* pp = head[p];
	while(pp != NULL)
	{
		int v = pp -> v;
		dfs(c,v);
		pp = pp -> nex;
	}
}
int main()
{
	cin >> n;
	for(int i = 1;i <= n;i++)
	{
		int u,v;cin >> u >> v;
		du[u]++,du[v]++;
		add(u,v);
		add(v,u);
	}
	tp();
	for(int i = 1;i <= n;i++)
	{
		if(!unable[i])
		{
			color[i] = co;
			edge* p = head[i];
			while(p != NULL)
			{
				int v = p -> v;
				dfs(co,v);
				p = p -> nex;
			}
			co++;
		}
	}
	cin >> q;
	while(q--)
	{
		int u,v;cin >> u >> v;
		if(color[u] == color[v])
			cout << "Yes" << endl;
		else
			cout << "No" << endl;
	}
}
```

## 差分约束

### 对于形如：

$$
\begin{cases}
x_{c_{1}}-x_{c_{1}'}\leq y_1 \\
x_{c_{2}}-x_{c_{2}'}\leq y_2 \\
...\\
x_{c_{n}}-x_{c_{n}'}\leq y_n \\
\end{cases}
$$

### 对于单个式子而言$x_{c_{1}}-x_{c_{1}'}\leq y_1$，可转换为$x_{c_{1}}\leq x_{c_{1}'}+y_1$，而在图论中的点与点的距离也可以表示成这种样子，也就是点$c_1'$到$c_1$有一条权值为$y_1$的单向边

### 建图，用SPFA判断是否有负环即可判断是否有解，并且最后的dis就是一个可行解

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define fo(i,n) for(int i = 1;i <= n;i++)
#define debug(i,x) cout << "case" << (i) << ":" << x << endl;
#define lson(x) (x << 1)
#define rson(x) (x << 1 | 1)
const int inf = 1e9;
const int MAXN = 5e3 + 10;
ll num[MAXN],dis[MAXN];
bool use[MAXN];
vector<pair<int,int>> ed[MAXN];
int n,m;
void init(){
	memset(dis,1e9,sizeof(dis));
}
bool spfa(){
	dis[1] = 0;
	queue<int> qu;
	fo(i,n){
		qu.push(i);
		use[i] = 1;
		num[i]++;
	}
	while(!qu.empty()){
		int u = qu.front();
		use[u] = 0;
		qu.pop();
		for(auto pa:ed[u]){
			int v = pa.first,ddis = pa.second;
			if(ddis + dis[u] < dis[v]){
				dis[v] = ddis + dis[u];
				if(!use[v]){
					num[v]++;
					use[v] = 1;
					qu.push(v);
					if(num[u] >= n)//出现负环
						return 0;
				}
			}
		}
	}
	return 1;
}
int main()
{
	cin >> n >> m;
	init();
	for(int i = 1;i <= m;i++){
		int u,v,dis;cin >> u >> v >> dis;
		ed[v].push_back({u,dis});
	}
	bool f = 1;
	if(!spfa()){
		f = 0;
	}
	if(f)
		fo(i,n)
			cout << dis[i] << ' ';
	else
		cout << "NO" << endl;
}
```

## 负环

* SPFA算法求最短路，会在负环死循环，根据正常图的点最多经历n - 1轮松弛可知只要一个点经过了多余n - 1轮就可以说明这个图有负环

```c++
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 2e3 + 10,MAXM = 3e3 + 10,INF = 0x3f3f3f3f;
struct edge{
	int v,val;
	edge* nex;
}ed[MAXM * 2];
edge* head[MAXN];
int ptop = 0;
void add_edge(int u,int v,int val)
{
	ed[ptop].v = v,ed[ptop].val = val;
	ed[ptop].nex = head[u];
	head[u] = &ed[ptop];
	ptop++;
}
int num[MAXN];
int dis[MAXN];
int n,m;
bool spfa()
{
	queue<int> qu;
	qu.push(1);
	dis[1] = 0;
	while(!qu.empty())
	{
		int x = qu.front();
		qu.pop();
		if(num[x] >= n)
		return true;
		num[x]++;
		edge* p = head[x];
		while(p != NULL)
		{
			int y = p -> v,val = p -> val;
			if(val + dis[x] < dis[y])
			{
				dis[y] = val + dis[x];
				qu.push(y);
			}
			p = p -> nex;
		}
	}
	return false;
}
void pre()
{
	for(int i = 1;i <= n;i++)
	{
		head[i] = NULL;
		num[i] = 0;
		dis[i] = INF;
	}
	ptop = 0;
}
int main()
{
	int t;cin >> t;
	while(t--)
	{
		cin >> n >> m;
		pre();
		for(int i = 1;i <= m;i++)
		{
			int u,v,val;cin >> u >> v >> val;
			if(val >= 0)
			add_edge(v,u,val);
			add_edge(u,v,val);
		}
		if(spfa())
		cout << "YES" << endl;
		else
		cout << "NO" << endl;
	}
}
```

## 最大流问题

### 给出起点、终点、边最大能传递的值，问从起点到终点最多能传多少

* 阻塞流：不能再给终点增加值的流（最大流就是一种阻塞流）
* 传统算法：新建一个剩余量的图，找路径、减去最小值、删路径，重复直到为阻塞流（不一定为最优解）

### Ford-Fulkerson算法(复杂度O(fm)，没什么用，过不了模板题)

### 相对于传统算法，它加入了一步建立反向边的步骤使得它可以"反悔"

### 1.找路径

### 2.减去最小值并建立反向的最小值边

### 3.重复

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll ans = 0;
const int MAXN = 201,MAXM = 5e3 + 10;
struct edge{
	ll v,val,i;
	edge* nex;
}ed[MAXM*2];
int ptop;
edge* head[MAXN];
void add(int u,int v,ll val){
	ed[ptop].i = ptop;
	ed[ptop].v = v;
	ed[ptop].nex = head[u];
	ed[ptop].val = val;
	head[u] = &ed[ptop];
	ptop++;
	ed[ptop].v = u;
	ed[ptop].i = ptop;
	ed[ptop].nex = head[v];
	ed[ptop].val = 0;
	head[v] = &ed[ptop];
	ptop++;
}
int s,t;
int ask[MAXM*2],use[MAXN];
bool find(int u){
	if(u == t)
		return 1;
	edge* p = head[u];
	for(edge* p = head[u];p != NULL;p = p -> nex){
		int v = p -> v;
		if(use[v] || p -> val == 0)
			continue;
		else{
			use[v] = 1;
			ask[++ptop] = p -> i;
			if(find(v))	return 1;
			ptop--;
		}	
	}
	return 0;
}
bool bfs(){
	ptop = 0;
	memset(use,0,sizeof(use));
	use[s] = 1;
	if(!find(s))
		return 0;
	ll mi = (ll)1 << 50;
	for(int i = 1;i <= ptop;i++){
		mi = min(mi,ed[ask[i]].val);
	}
	for(int i = 1;i <= ptop;i++){
		ed[ask[i]].val -= mi;
		ed[ask[i]^1].val += mi;
	}
	ans += mi;
	return 1;
}
int main()
{
	int n,m;cin >> n >> m >> s >> t;
	for(int i = 1;i <= m;i++){
		ll u,v,val;cin >> u >> v >> val;
		add(u,v,val);
	}
	while(bfs());
	cout << ans;
}
```

### Edmonds-Karp算法(用最短路找边，时间复杂度为O($m^2n$))(SAP算法)

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll ans = 0;
const int MAXN = 201,MAXM = 5e3 + 10;
struct edge{
	ll u,v,val,i;
	edge* nex;
}ed[MAXM*2];
int ptop = 2;
edge* head[MAXN];
void add(int u,int v,ll val){
	ed[ptop].i = ptop;
	ed[ptop].v = v;
	ed[ptop].u = u;
	ed[ptop].nex = head[u];
	ed[ptop].val = val;
	head[u] = &ed[ptop];
	ptop++;
	ed[ptop].v = u;
	ed[ptop].u = v;
	ed[ptop].i = ptop;
	ed[ptop].nex = head[v];
	ed[ptop].val = 0;
	head[v] = &ed[ptop];
	ptop++;
}
int s,t;
int pre[MAXN*2],use[MAXN];
bool find(){
	queue<int> qu;qu.push(s);
	while(!qu.empty()){
		int x = qu.front();
		qu.pop();
		for(edge* p = head[x];p != NULL;p = p -> nex){
			int v = p -> v;
			if(use[v] || p -> val == 0)
				continue;
			pre[v] = p -> i;
			use[v] = 1;
			if(v == t)
				return 1;
			qu.push(v);
		}
	}
	return 0;
}
bool bfs(){
	ptop = 0;
	memset(use,0,sizeof(use));
	use[s] = 1;
	if(!find())
		return 0;
	ll mi = (ll)1 << 50;
	for(int i = pre[t];i != 0;i = pre[ed[i].u]){
		mi = min(mi,ed[i].val);
	}
	for(int i = pre[t];i != 0;i = pre[ed[i].u]){
		ed[i].val -= mi;
		ed[i^1].val += mi;
	}
	ans += mi;
	return 1;
}
int main()
{
	int n,m;cin >> n >> m >> s >> t;
	for(int i = 1;i <= m;i++){
		ll u,v,val;cin >> u >> v >> val;
		add(u,v,val);
	}
	while(bfs());
	cout << ans;
}
```

### Dinic算法

* level-up图：就是分层图，起点开始，终点结束，中间分层
* Edmonds-Karp算法每次只解决一条边，效率较低，Dinic算法通过level-up图算一个图的阻塞流，效率更高
* BFS找level-up图思路：记录深度，最后看终点有没有被标记深度即可
* DFS找阻塞流：每次只找深度加1的点，深入DFS并传递边的最小值，返回分配的流，让这条边减去返回值，继续找，直到找完或者没有流可以继续了

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define inf 0x3f3f3f3f
const int MAXN = 201,MAXM = 5e3 + 10;
struct edge{
	int v;
	ll w;
	edge* nex;
	int i;
}ed[MAXM*2];
edge* head[MAXN];
int ptop = 0;
void add(int u,int v,ll w){
	ed[ptop].w = w;
	ed[ptop].v = v;
	ed[ptop].nex = head[u];
	head[u] = &ed[ptop];
	ed[ptop].i = ptop;
	ptop++;
	ed[ptop].w = 0;
	ed[ptop].v = u;
	ed[ptop].nex = head[v];
	head[v] = &ed[ptop];//构造反向边
	ed[ptop].i = ptop;
	ptop++;
}
int n,m,s,t;
int d[MAXN];//记录深度
bool bfs(){//构造levelup图
	queue<int> qu;
	memset(d,-1,sizeof(d));
	d[s] = 0;
	qu.push(s);//放入起点
	while(!qu.empty()){
		int u = qu.front();
		qu.pop();
		edge* p = head[u];
		while(p != NULL){
			int v = p -> v;
			if(p -> w && d[v] == -1){//存在且还没加入图
				d[v] = d[u] + 1;
				qu.push(v);
			}
			p = p -> nex;
		}
	}
	if(d[t] == -1)//到不了终点
		return 0;
	else
		return 1;
}
ll dfs(int u,ll flow){
	if(u == t)
		return flow;
	edge* p = head[u];
	ll use = 0;
	while(p != NULL){
		int v = p -> v;
		if(d[v] == d[u] + 1 && p -> w){
			ll tem = dfs(v,min(flow,p -> w));
			flow -= tem;
			ed[p -> i].w -= tem;
			ed[(p -> i) ^ 1].w += tem;
			use += tem;
			if(flow == 0)
				break;
		}
		p = p -> nex;
	}
	if(use == 0) d[u] = -1;
	return use;
}
ll dinic(){
	ll ans = 0;
	while(bfs()){
		ans += dfs(s,inf);
	}
	return ans;
}
int main()
{
	cin >> n >> m >> s >> t;
	for(int i = 1;i <= m;i++){
		int u,v,w;cin >> u >> v >> w;
		add(u,v,w);
	}
	cout << dinic();
}
```

### ISAP算法

### 最小割等价于最大流问题

* 因为所有流都要经过割，因此所有流都大于等于割，那么最大的流就等价于最小的割
* 随便用一个最大流算法处理图，从起点出发将所有找到的点加入S集合，另外的为T集合，这样就找到最小割了(不唯一)

### EK(SPFA版)费用流

* 费用流：最大流中费用最小的
* EK算法每次都找一条可行路径，那么只要一直找费用最小的可行路径即可

* 每次都找一条费用最小的路径，反向边的费用是正向边的负权值

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 5e4 + 10,M = 5e5 + 10,INF = 0x7f7f7f7f;
int n,m,s,t,ans1,ans2;

struct edge{
	int v,flow,cost,i;
	edge* nex;
}ed[M];
int ptop = 0;
edge* head[N];
void add(int u,int v,int flow,int cost){
	ed[ptop].v = v;
	ed[ptop].flow = flow;
	ed[ptop].cost = cost;
	ed[ptop].i = ptop;
	ed[ptop].nex = head[u];
	head[u] = &ed[ptop];
	ptop++;
	ed[ptop].v = u;
	ed[ptop].flow = 0;
	ed[ptop].cost = -cost;//反向路径费用为负
	ed[ptop].i = ptop;
	ed[ptop].nex = head[v];
	head[v] = &ed[ptop];
	ptop++;
}

int pre[M],newcost[N],Flow[N];
bool vis[N];

inline bool spfa(){
	queue<int> qu;qu.push(s);vis[s] = 1;
	memset(Flow,0,sizeof(Flow));Flow[s] = INF;//起点流量无限
	memset(newcost,INF,sizeof(newcost));newcost[s] = 0;//起点费用为0
	memset(pre,0,sizeof(pre));
	while(!qu.empty()){
		int u = qu.front();
		qu.pop();
		vis[u] = 0;
		for(auto* p = head[u];p != NULL;p = p -> nex){
			int v = p -> v;
			if(p -> flow > 0 && newcost[v] > newcost[u] + p -> cost){//是否能更新这个点
				newcost[v] = newcost[u] + p -> cost;//更新点的费用
				Flow[v] = min(Flow[u],p -> flow);//更新流量
				pre[v] = p -> i;//记录这条边
				if(!vis[v]){vis[v] = 1,qu.push(v);}
			}
		}
	}
	return newcost[t] != INF;
}

void EK(){
	while(spfa()){
		ans1 += Flow[t],ans2 += newcost[t]*Flow[t];
		int u = t;
		while(u != s){
			int k = pre[u];
			ed[k].flow -= Flow[t];
			ed[k^1].flow += Flow[t];
			u = ed[k^1].v;
		}
	}
}

int main(){
	cin >> n >> m >> s >> t;
	for(int i = 1;i <= m;i++){
		int u,v,flow,cost;
		cin >> u >> v >> flow >> cost;
		add(u,v,flow,cost);
	}
	EK();
	cout << ans1 << ' ' << ans2 << endl;
}
```

## tarjan算法（求强连通分量）（缩点）

### 强连通：两个点相互可达

### 强连通分量：集合中的点两两可达

### 思路：记录自己的时间戳dfs与能到达的最小时间戳low，先dfs搜索完自己能到达的点，如果更新后的最小时间戳low与己的时间戳dfs相等说明自己就是那个强连通分量顶点，如果不相等说明它可以到达更小的时间戳，那么在回溯到那个点时再处理

### 题目：

### 1.计算强连通分量数量

### [迷宫城堡](https://acm.hdu.edu.cn/showproblem.php?pid=1269)

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 3e5 + 10;
stack<int> st;
bool in[N];//是否在栈内
int dfs[N],low[N];
vector<int> ed[N];
int ptop = 0;
int num = 0;//记录强连通分量的数量
void tarjan(int x){
	dfs[x] = low[x] = ++ptop;
	st.push(x);
	in[x] = 1;
	for(auto y : ed[x]){
		if(!dfs[y])
			tarjan(y);
        else if(in[y])
			low[x] = min(low[x],low[y]);
	}
	if(low[x] == dfs[x]){
		int y;
		num++;
		do{
			y = st.top();
			st.pop();
			in[y] = 0;
		}while(y != x);
	}
}
int n,m;
void init(){
	num = ptop = 0;
	for(int i = 1;i <= n;i++){
		in[i] = dfs[i] = low[i] = 0;
		ed[i].clear();
	}
}
int main()
{
	cin >> n >> m;
	while(n != 0){
		init();
		for(int i = 1;i <= m;i++){
			int u,v;cin >> u >> v;
			ed[u].push_back(v);
		}
		for(int i = 1;i <= n;i++)
			if(!dfs[i])
				tarjan(i);
		if(num == 1)
			cout << "Yes" << endl;
		else
			cout << "No" << endl;
		cin >> n >> m;
	}
}
```

### 2.变成强连通图的最小连接数

### [Proving Equivalences](https://acm.hdu.edu.cn/showproblem.php?pid=2767)

### 思路：先用tarjan缩点，然后看新的图，如果要让新的图变成强连通图，就要让每个点都有入有出，如果原图是强连通图，那么新加一点也要让其依旧为强连通图，那么只要随便连一条边进入原图，再从原图拉一条边出来，因为原图是强连通图，所以所有点两两相通，也就包括从原图连入与连出的点，因此对于强连通图来说，只要每个点都有入有出即可变为强连通图

### 但是如果强连通分量彼此分立那就不行，因此先用tarjan将强连通分量整合即可

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 3e5 + 10;
stack<int> st;
bool in[N];//是否在栈内
int dfs[N],low[N];
int _in[N],_out[N];
vector<int> ed[N];
int belong[N];//缩点
int ptop = 0;
int num = 0;//记录强连通分量的数量
void tarjan(int x){
	dfs[x] = low[x] = ++ptop;
	st.push(x);
	in[x] = 1;
	for(auto y : ed[x]){
		if(!dfs[y]){
			tarjan(y);
			low[x] = min(low[x],low[y]);
		}
		else if(in[y])
			low[x] = min(low[x],dfs[y]);
	}
	if(low[x] == dfs[x]){
		int y;
		num++;
		do{
			y = st.top();
			st.pop();
			in[y] = 0;
			belong[y] = num;
		}while(y != x);
	}
}
int n,m;
void init(){
	num = ptop = 0;
	for(int i = 1;i <= n;i++){
		dfs[i] = low[i] = 0;
		_in[i] = _out[i] = 0;
		ed[i].clear();
	}
}
int main()
{
	ios::sync_with_stdio(false);//写了using namespace std;
	int t;cin >> t;
	while(t--){
		cin >> n >> m;
		init();
		for(int i = 1;i <= m;i++){
			int u,v;cin >> u >> v;
			ed[u].push_back(v);
		}
		for(int i = 1;i <= n;i++)
			if(!dfs[i])
				tarjan(i);
		if(num == 1){
			cout << 0 << endl;
			continue;
		}
		for(int i = 1;i <= n;i++){
			for(auto x:ed[i]){
				if(belong[x] != belong[i]){
					_in[belong[x]]++;
					_out[belong[i]]++;
				}
			}
		}
		int __in = 0,__out = 0;
		for(int i = 1;i <= num;i++){
			if(_in[i] == 0)
				__in++;
			if(_out[i] == 0)
				__out++;
		}
		cout << max(__in,__out) << endl;
	}
}
```

### 3.让所有点都能流到需要的最小费用

### [Summer Holiday](https://acm.hdu.edu.cn/showproblem.php?pid=1827)

### 题意：联系第$i$人需要$a_i$的费用，那些人有些又可以联系其他人，问最小的费用联系到所有人

### 思路：先缩点，然后看入边，如果入边为0说明需要联系，在这个集合里找最小加上即可

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 3e5 + 10;
stack<int> st;
bool in[N];//是否在栈内
int dfs[N],low[N];
vector<int> ed[N];
int belong[N];//缩点
int ptop = 0;
int num = 0;//记录强连通分量的数量
void tarjan(int x){
	dfs[x] = low[x] = ++ptop;
	st.push(x);
	in[x] = 1;
	for(auto y : ed[x]){
		if(!dfs[y]){
			tarjan(y);
			low[x] = min(low[x],low[y]);
		}
		else if(in[y])
			low[x] = min(low[x],dfs[y]);
	}
	if(low[x] == dfs[x]){
		int y;
		num++;
		do{
			y = st.top();
			st.pop();
			in[y] = 0;
			belong[y] = num;
		}while(y != x);
	}
}
int n,m;
int mi[N];
int _in[N];
void init(){
	num = ptop = 0;
	for(int i = 1;i <= n;i++){
		dfs[i] = low[i] = 0;
		_in[i] = 0;
		ed[i].clear();
		mi[i] = 1e9;
	}
}
int a[N];
int main()
{
	ios::sync_with_stdio(false);//写了using namespace std;
	while(cin >> n >> m){
		init();
		for(int i = 1;i <= n;i++)
			cin >> a[i];
		for(int i = 1;i <= m;i++){
			int u,v;cin >> u >> v;
			ed[u].push_back(v);
		}
		for(int i = 1;i <= n;i++)
			if(!dfs[i])
				tarjan(i);
		for(int i = 1;i <= n;i++){
			for(auto x : ed[i]){
				if(belong[x] != belong[i]){
					_in[belong[x]]++;
				}
			}
		}
		for(int i = 1;i <= n;i++)
			mi[belong[i]] = min(a[i],mi[belong[i]]);
		int ans = 0,nnum = 0;
		for(int i = 1;i <= num;i++){
			if(_in[i] == 0){
				ans += mi[i];
				nnum++;
			}
		}
		cout << nnum << ' ' << ans << endl;
	}
}
```

### 4.割点

#### 其实割点不需要tarjan的栈之类的，用dfs就能解决，参考了tarjan的时间戳的思想

#### 定义：去掉该点后使得原本该点所在的树不连通

#### 思路：我们从一个点开始搜索，将它当作根，如果它搜索了两个即以上不相连的子树，那么说明这个点为割点，如果是被搜索到的点，说明上面为一连通部分，那么只要有一个子树的最小能到达时间戳大于等于该节点，说明子树被这个点与上面分开，那么这个点就为割点

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 3e5 + 10;
stack<int> st;
int dfs[N],low[N];
vector<int> ed[N];
bool is[N];
int ptop = 0;
int cnt = 0;
int root;
void tarjan(int x){
	dfs[x] = low[x] = ++ptop;
	st.push(x);
	int son = 0;
	for(auto y : ed[x]){
		if(!dfs[y]){
			son++;
			tarjan(y);low[x] = min(low[x],low[y]);
			if(low[y] >= dfs[x] && x != root){
				cnt += !is[x];
				is[x] = 1;
			}
		}else
			low[x] = min(low[x],dfs[y]);
	}
	if(son >= 2 && root == x){
		cnt += !is[x];
		is[x] = 1;
	}
}
int n,m;
int main()
{
	cin >> n >> m;
	for(int i = 1;i <= m;i++){
		int u,v;cin >> u >> v;
		ed[u].push_back(v);
		ed[v].push_back(u);
	}
	for(int i = 1;i <= n;i++){
		if(!dfs[i]){
			root = i;
			tarjan(i);
		}
	}
	cout << cnt << endl;
	for(int i = 1;i <= n;i++)
		if(is[i])
			cout << i << ' ';
}
```

## 二分图（二部图）

### 概念：可分为两个集合，集合内的点无边相连的图

### 判定：染色法

```c++
int col[MAXN];
vector<int> ed[MAXN];
bool bfs(){
	col[1] = 1;
	queue<int> qu;
	while(!qu.empty()){
		int u = qu.front();
		qu.pop();
		for(auto v:ed[u]){
			if(!col[v]){
				col[v] = 2 - col[u];
				qu.push(v);
			}else if(col[v] == col[u])
				return 0;
		}
	}
	return 1;
}
```

## 无权二部图最大匹配问题

* 匹配：每个节点都只连一条边的边集合

### 转换为最大流问题

* 设置一个起点，连接集合S的所有点，权值为1，设置一个终点，连接集合T的所有点，权值为1，求最大匹配等价于求起点到终点的最大流

```c++
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1e3 + 20,MAXE = 5e4 + MAXN;
#define inf 0x3f3f3f3f
struct edge{
	int v,w;
	int i;
	edge* nex;
}ed[MAXE*2];
edge* head[MAXN];
int ptop = 0;
void add(int u,int v){
	ed[ptop].v = v;
	ed[ptop].w = 1;
	ed[ptop].nex = head[u];
	head[u] = &ed[ptop];
	ed[ptop].i = ptop;
	ptop++;
	ed[ptop].v = u;
	ed[ptop].w = 0;
	ed[ptop].nex = head[v];
	head[v] = &ed[ptop];
	ed[ptop].i = ptop;
	ptop++;
}
int d[MAXN];
int s = 0,t;
bool bfs(){
	queue<int> qu;
	qu.push(s);
	memset(d,-1,sizeof(d));
	d[s] = 0;
	while(!qu.empty()){
		int u = qu.front();
		qu.pop();
		edge* p = head[u];
		while(p != NULL){
			int v = p -> v;
			if(p -> w && d[v] == -1){
				d[v] = d[u] + 1;
				qu.push(v);
			}
			p = p -> nex;
		}
	}
	if(d[t] == -1)
		return 0;
	else
		return 1;
}
int dfs(int u,int flow){
	edge* p = head[u];
	if(u == t)
		return flow;
	int use = 0;
	while(p != NULL){
		int v = p -> v;
		if(d[v] == d[u] + 1 && p -> w){
			int tem = dfs(v,min(flow,p -> w));
			use += tem;
			flow -= tem;
			ed[p -> i].w -= tem;
			ed[(p -> i)^1].w += tem;
			if(flow == 0)
				break;
		}
		p = p -> nex;
	}
	if(use == 0)
		d[u] = -1;
	return use;
}
int dinic(){
	int ans = 0;
	while(bfs()){
		ans += dfs(s,inf);
	}
	return ans;
}
int main()
{
	int n,m,e;cin >> n >> m >> e;
	for(int i = 1;i <= n;i++)
		add(s,i);
	t = n + m + 1;
	for(int i = 1 + n;i < t;i++)
		add(i,t);
	for(int i = 1;i <= e;i++)
	{
		int u,v;cin >> u >> v;
		v += n;
		add(u,v);
	}
	cout << dinic();
}
```

## 2-SAT

* 对于二元条件并且，元素只有两个可能，如果非A，那么就可以推出B，同理非B就可以推出A，那么就可以建图，不可能成立的情况就是A与非A形成了一个环，用tarjan找环，然后tarjan给出的color就是拓扑逆序，那么为了防止A推得非A，那么只要输出color小的可能性就是拓扑后面的位置

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e6 + 10;

vector<int> ed[N*2];

stack<int> st;
bool in[N*2];//是否在栈内
int dfs[N*2],low[N*2];
int ptop = 0;
int num = 0;//记录强连通分量的数量
int c[N*2];
void tarjan(int x){
	dfs[x] = low[x] = ++ptop;
	st.push(x);
	in[x] = 1;
	for(auto y : ed[x]){
		if(!dfs[y])
			tarjan(y);
		else if(in[y])
			low[x] = min(low[x],low[y]);
	}
	if(low[x] == dfs[x]){
		int y;
		num++;
		do{
			c[y] = num;
			y = st.top();
			st.pop();
			in[y] = 0;
		}while(y != x);
		c[x] = num;
	}
}
int n,m;

int main(){
	cin >> n >> m;
	for(int k = 1;k <= m;k++){
		int i,a,j,b;cin >> i >> a >> j >> b;
		if(a) i = 2*n - i + 1;
		if(b) j = 2*n - j + 1;
		i = 2*n - i + 1;
		ed[i].push_back(j);
		i = 2*n - i + 1;
		j = 2*n - j + 1;
		ed[j].push_back(i);
	}
	bool f = 1;
	for(int i = 1;i <= n*2;i++) {
		if(!dfs[i]) {
			tarjan(i);
		}
	}
	for(int i = 1;i <= n;i++){
		if(c[i] == c[2*n + 1 - i]) f = 0;
	}
	if(!f) cout << "IMPOSSIBLE" << '\n';
	else{
		cout << "POSSIBLE" << '\n';
		for(int i = 1;i <= n;i++)
			cout <<	(c[2*n - i + 1] < c[i]) << ' ';
	}
}
```



